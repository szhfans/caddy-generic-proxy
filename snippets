import { connect } from "cloudflare:sockets";

const FIXED_UUID = '9d8f6f73-0038-42ea-bc7c-a6243f4f3e98';

// ProxyIP ÈÖçÁΩÆ - ÊîØÊåÅÁ´ØÂè£
const PROXY_IPS = [
  '',     // ÈªòËÆ§443
  // 'proxyip2.com:8080',
];

// DNSÁºìÂ≠ò
if (!globalThis.dnsCache) globalThis.dnsCache = new Map();
const DNS_TTL = 5 * 60 * 1000;

export default {
  async fetch(request) {
    if (request.headers.get("Upgrade") !== "websocket") {
      const dnsInfo = {};
      for (const [hostname, data] of globalThis.dnsCache.entries()) {
        dnsInfo[hostname] = {
          ips: data.ips,
          age: Math.round((Date.now() - data.timestamp) / 1000) + 's'
        };
      }
      
      return new Response(JSON.stringify({
        status: "VLESS Proxy - Correct Logic",
        proxyIPs: PROXY_IPS,
        dnsCache: dnsInfo,
      }, null, 2), { 
        headers: { "Content-Type": "application/json" } 
      });
    }

    const [client, server] = Object.values(new WebSocketPair());
    server.accept();

    createWebSocketStream(server, request.headers.get("sec-websocket-protocol") || "")
      .pipeTo(new WritableStream({
        async write(chunk) {
          if (this.tcpWriter) {
            await this.tcpWriter.write(chunk);
            return;
          }

          const vless = parseVLESS(chunk);
          if (vless.error) throw new Error(vless.error);

          const payload = chunk.slice(vless.dataIndex);
          
          let tcpSocket;
          let isUsingProxy = false;
          
          try {
            // 1. Â∞ùËØïÁõ¥ËøûÁõÆÊ†á
            console.log(`üéØ Direct: ${vless.address}:${vless.port}`);
            tcpSocket = await connectWithTimeout(vless.address, vless.port);
            console.log(`‚úÖ Direct OK: ${vless.address}:${vless.port}`);
          } catch (directError) {
            console.log(`‚ùå Direct failed: ${directError.message}`);
            
            // 2. Áõ¥ËøûÂ§±Ë¥•ÔºåÂ∞ùËØï‰ª£ÁêÜ
            tcpSocket = await connectViaProxy();
            isUsingProxy = true;
          }
          
          this.tcpSocket = tcpSocket;
          this.tcpWriter = tcpSocket.writable.getWriter();
          
          if (payload.byteLength > 0) {
            await this.tcpWriter.write(payload);
          }
          
          const responseHeader = new Uint8Array([vless.version, 0]);
          startTcpToWebSocket(tcpSocket, server, responseHeader);
        },
        close() { 
          try { 
            this.tcpWriter?.releaseLock();
            this.tcpSocket?.close(); 
          } catch {} 
        }
      }))
      .catch((err) => {
        console.error("Stream error:", err.message);
        server.close();
      });

    return new Response(null, { status: 101, webSocket: client });
  }
};

// ÈÄöËøá‰ª£ÁêÜËøûÊé•
async function connectViaProxy() {
  if (PROXY_IPS.length === 0) {
    throw new Error("No proxy available");
  }

  for (const proxyStr of PROXY_IPS) {
    try {
      const proxyConfig = await getProxyConfig(proxyStr);
      console.log(`üåê Proxy: ${proxyConfig.host}:${proxyConfig.port}`);
      
      const socket = await connectWithTimeout(proxyConfig.host, proxyConfig.port);
      console.log(`‚úÖ Proxy OK: ${proxyConfig.host}:${proxyConfig.port}`);
      return socket;
    } catch (proxyError) {
      console.log(`‚ùå Proxy failed: ${proxyStr} - ${proxyError.message}`);
      continue;
    }
  }
  
  throw new Error("All proxies failed");
}

// Ëé∑Âèñ‰ª£ÁêÜÈÖçÁΩÆÔºàÈöèÊú∫IPÔºâ
async function getProxyConfig(proxyStr) {
  const parsed = parseProxy(proxyStr);
  
  if (isIPAddress(parsed.host)) {
    return parsed;
  }
  
  // ÂüüÂêçËß£ÊûêÂêéÈöèÊú∫ÈÄâÊã©IP
  const ips = await resolveDNS(parsed.host);
  const randomIP = ips[Math.floor(Math.random() * ips.length)];
  console.log(`üé≤ Random IP: ${randomIP} from ${parsed.host} (${ips.length} total)`);
  
  return { host: randomIP, port: parsed.port };
}

// Ëß£Êûê‰ª£ÁêÜÂ≠óÁ¨¶‰∏≤
function parseProxy(proxyStr) {
  const trimmed = proxyStr.trim();
  if (trimmed.includes(':')) {
    const parts = trimmed.split(':');
    const port = parseInt(parts[parts.length - 1]);
    if (!isNaN(port) && port > 0 && port <= 65535) {
      const host = parts.slice(0, -1).join(':');
      return { host: host.trim(), port };
    }
  }
  return { host: trimmed, port: 443 };
}

// DNSËß£Êûê
async function resolveDNS(hostname) {
  if (globalThis.dnsCache.has(hostname)) {
    const cached = globalThis.dnsCache.get(hostname);
    if (Date.now() - cached.timestamp < DNS_TTL) {
      return cached.ips;
    }
  }

  try {
    console.log(`üîç DNS: ${hostname}`);
    const response = await fetch(`https://cloudflare-dns.com/dns-query?name=${hostname}&type=A`, {
      headers: { 'Accept': 'application/dns-json' }
    });
    
    if (!response.ok) {
      throw new Error(`DNS query failed: ${response.status}`);
    }
    
    const data = await response.json();
    const ips = [];
    
    if (data.Answer) {
      for (const record of data.Answer) {
        if (record.type === 1) {
          ips.push(record.data);
        }
      }
    }
    
    if (ips.length > 0) {
      globalThis.dnsCache.set(hostname, { ips, timestamp: Date.now() });
      console.log(`‚úÖ DNS: ${hostname} ‚Üí [${ips.join(', ')}]`);
      return ips;
    }
  } catch (error) {
    console.warn(`‚ùå DNS failed: ${hostname} - ${error.message}`);
  }
  
  return [hostname];
}

function connectWithTimeout(hostname, port, timeout = 5000) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new Error(`Timeout ${timeout}ms`));
    }, timeout);

    const socket = connect({ hostname, port });
    socket.opened
      .then(() => {
        clearTimeout(timer);
        resolve(socket);
      })
      .catch((err) => {
        clearTimeout(timer);
        reject(err);
      });
  });
}

async function startTcpToWebSocket(tcpSocket, webSocket, responseHeader) {
  const reader = tcpSocket.readable.getReader();
  let headerSent = false;
  
  try {
    while (true) {
      if (webSocket.readyState !== 1) break;
      
      const { value, done } = await reader.read();
      if (done) break;
      
      if (!headerSent) {
        const combined = new Uint8Array(responseHeader.byteLength + value.byteLength);
        combined.set(responseHeader, 0);
        combined.set(value, responseHeader.byteLength);
        webSocket.send(combined.buffer);
        headerSent = true;
      } else {
        if (value.byteOffset === 0 && value.byteLength === value.buffer.byteLength) {
          webSocket.send(value.buffer);
        } else {
          webSocket.send(value);
        }
      }
    }
  } catch (e) {
    console.warn("Transfer error:", e.message);
  } finally {
    reader.releaseLock();
    if (webSocket.readyState === 1) webSocket.close();
  }
}

function isIPAddress(str) {
  return /^(\d{1,3}\.){3}\d{1,3}$/.test(str);
}

function createWebSocketStream(ws, earlyData) {
  return new ReadableStream({
    start(controller) {
      ws.addEventListener("message", e => {
        if (typeof e.data === "string" && (e.data === "pong" || e.data === "ping")) return;
        controller.enqueue(e.data);
      });
      ws.addEventListener("close", () => controller.close());
      ws.addEventListener("error", e => controller.error(e));

      if (earlyData) {
        try {
          const decoded = atob(earlyData.replace(/-/g, "+").replace(/_/g, "/"));
          const data = Uint8Array.from(decoded, c => c.charCodeAt(0));
          controller.enqueue(data.buffer);
        } catch (e) {
          console.warn("Early data failed:", e);
        }
      }
    }
  });
}

function parseVLESS(buffer) {
  if (buffer.byteLength < 24) return { error: "Êï∞ÊçÆÂåÖÈïøÂ∫¶‰∏çË∂≥" };

  const view = new DataView(buffer);
  const version = view.getUint8(0);

  const uuid = Array.from(new Uint8Array(buffer.slice(1, 17)),
    b => b.toString(16).padStart(2, "0")).join("");
  const formattedUUID = `${uuid.slice(0,8)}-${uuid.slice(8,12)}-${uuid.slice(12,16)}-${uuid.slice(16,20)}-${uuid.slice(20)}`;

  if (FIXED_UUID && formattedUUID !== FIXED_UUID) return { error: "Êó†ÊïàUUID" };

  const optLen = view.getUint8(17);
  const command = view.getUint8(18 + optLen);
  if (command !== 1) return { error: "‰ªÖÊîØÊåÅTCP" };

  let offset = 19 + optLen;
  const port = view.getUint16(offset);
  offset += 2;

  const addrType = view.getUint8(offset++);
  let address = "";

  switch (addrType) {
    case 1:
      address = Array.from(new Uint8Array(buffer.slice(offset, offset + 4))).join(".");
      offset += 4;
      break;
    case 2:
      const len = view.getUint8(offset++);
      address = new TextDecoder().decode(buffer.slice(offset, offset + len));
      offset += len;
      break;
    case 3:
      const ipv6 = [];
      for (let i = 0; i < 8; i++) {
        ipv6.push(view.getUint16(offset).toString(16));
        offset += 2;
      }
      address = ipv6.join(":");
      break;
    default:
      return { error: "‰∏çÊîØÊåÅÁöÑÂú∞ÂùÄÁ±ªÂûã" };
  }

  return { version, address, port, dataIndex: offset };
}
